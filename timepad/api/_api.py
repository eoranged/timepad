# coding: utf-8

"""
    Timepad API

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from timepad.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_event(self, **kwargs):  # noqa: E501
        """Создать событие  # noqa: E501

        События создаются только от имени организаций. У пользователя, вызывающего этот метод, должны быть права на администрированое данной организации.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_event(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateEvent body: Описание создаваемого события
        :return: EventResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_event_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_event_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_event_with_http_info(self, **kwargs):  # noqa: E501
        """Создать событие  # noqa: E501

        События создаются только от имени организаций. У пользователя, вызывающего этот метод, должны быть права на администрированое данной организации.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_event_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateEvent body: Описание создаваемого события
        :return: EventResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_event" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['timepad_implicit']  # noqa: E501

        return self.api_client.call_api(
            '/v1/events', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_order(self, event_id, **kwargs):  # noqa: E501
        """Создать заказ (deprecated)  # noqa: E501

        Создает новый заказ для события. Это API более не предоставляется. В случае, если вас это напрямую затронуло, обратитесь в службу поддержки.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_order(event_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int event_id: Номер события (required)
        :param CreateOrder body: Описание создаваемого заказа
        :return: RegistrationOrderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_order_with_http_info(event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_order_with_http_info(event_id, **kwargs)  # noqa: E501
            return data

    def add_order_with_http_info(self, event_id, **kwargs):  # noqa: E501
        """Создать заказ (deprecated)  # noqa: E501

        Создает новый заказ для события. Это API более не предоставляется. В случае, если вас это напрямую затронуло, обратитесь в службу поддержки.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_order_with_http_info(event_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int event_id: Номер события (required)
        :param CreateOrder body: Описание создаваемого заказа
        :return: RegistrationOrderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `add_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['event_id'] = params['event_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/events/{event_id}/orders', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RegistrationOrderResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_organization(self, **kwargs):  # noqa: E501
        """Создать организацию  # noqa: E501

        Создает новую организацию на TimePad.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_organization(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateOrganization body: Описание созданной организации
        :return: OrganizationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_organization_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.add_organization_with_http_info(**kwargs)  # noqa: E501
            return data

    def add_organization_with_http_info(self, **kwargs):  # noqa: E501
        """Создать организацию  # noqa: E501

        Создает новую организацию на TimePad.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_organization_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateOrganization body: Описание созданной организации
        :return: OrganizationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_organization" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['timepad_implicit']  # noqa: E501

        return self.api_client.call_api(
            '/v1/organizations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrganizationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def approve_event_order(self, event_id, order_id, **kwargs):  # noqa: E501
        """Подтвердить заказ  # noqa: E501

        Устанавливает заказу статус - подтверждено  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.approve_event_order(event_id, order_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int event_id: Номер события, к которому относится заказ (required)
        :param int order_id: Номер заказа (required)
        :return: RegistrationOrderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.approve_event_order_with_http_info(event_id, order_id, **kwargs)  # noqa: E501
        else:
            (data) = self.approve_event_order_with_http_info(event_id, order_id, **kwargs)  # noqa: E501
            return data

    def approve_event_order_with_http_info(self, event_id, order_id, **kwargs):  # noqa: E501
        """Подтвердить заказ  # noqa: E501

        Устанавливает заказу статус - подтверждено  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.approve_event_order_with_http_info(event_id, order_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int event_id: Номер события, к которому относится заказ (required)
        :param int order_id: Номер заказа (required)
        :return: RegistrationOrderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id', 'order_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method approve_event_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `approve_event_order`")  # noqa: E501
        # verify the required parameter 'order_id' is set
        if ('order_id' not in params or
                params['order_id'] is None):
            raise ValueError("Missing the required parameter `order_id` when calling `approve_event_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['event_id'] = params['event_id']  # noqa: E501
        if 'order_id' in params:
            path_params['order_id'] = params['order_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['timepad_implicit']  # noqa: E501

        return self.api_client.call_api(
            '/v1/events/{event_id}/orders/{order_id}/approve', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RegistrationOrderResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def authorize(self, **kwargs):  # noqa: E501
        """Получить токен для работы с API  # noqa: E501

        Функция в закрытом тестировании. Для получения client_id обращайтесь в службу поддержки. Корректное выполнение этого запроса перенаправит пользователя на форму логина  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.authorize(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: Идентификатор клиента
        :param str redirect_uri: Ссылка на которую произойдёт редирект
        :param str response_type: Возвращаемый тип ответа. Единственное поддерживаемое значение - token
        :param list[str] scope: Запрашиваемые приложением разрешения через запятую. Возможные значения: add_events, add_organizations, edit_events, view_private_events, view_visitors, edit_visitors, add_cash_payments, edit_organizations_hooks
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.authorize_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.authorize_with_http_info(**kwargs)  # noqa: E501
            return data

    def authorize_with_http_info(self, **kwargs):  # noqa: E501
        """Получить токен для работы с API  # noqa: E501

        Функция в закрытом тестировании. Для получения client_id обращайтесь в службу поддержки. Корректное выполнение этого запроса перенаправит пользователя на форму логина  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.authorize_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str client_id: Идентификатор клиента
        :param str redirect_uri: Ссылка на которую произойдёт редирект
        :param str response_type: Возвращаемый тип ответа. Единственное поддерживаемое значение - token
        :param list[str] scope: Запрашиваемые приложением разрешения через запятую. Возможные значения: add_events, add_organizations, edit_events, view_private_events, view_visitors, edit_visitors, add_cash_payments, edit_organizations_hooks
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['client_id', 'redirect_uri', 'response_type', 'scope']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method authorize" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'client_id' in params:
            query_params.append(('client_id', params['client_id']))  # noqa: E501
        if 'redirect_uri' in params:
            query_params.append(('redirect_uri', params['redirect_uri']))  # noqa: E501
        if 'response_type' in params:
            query_params.append(('response_type', params['response_type']))  # noqa: E501
        if 'scope' in params:
            query_params.append(('scope', params['scope']))  # noqa: E501
            collection_formats['scope'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/oauth/authorize', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def call_custom_method(self, organization_id, method_name, **kwargs):  # noqa: E501
        """Вызвать кастомный метод  # noqa: E501

        Вызывает кастомный метод, определенный специально для вашей организации  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.call_custom_method(organization_id, method_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int organization_id: Идентификатор организации (required)
        :param str method_name: Название кастомного метода (required)
        :param CallCustomMethod body: Дополнительные параметры, передаваемые методу
        :return: CustomMethodApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.call_custom_method_with_http_info(organization_id, method_name, **kwargs)  # noqa: E501
        else:
            (data) = self.call_custom_method_with_http_info(organization_id, method_name, **kwargs)  # noqa: E501
            return data

    def call_custom_method_with_http_info(self, organization_id, method_name, **kwargs):  # noqa: E501
        """Вызвать кастомный метод  # noqa: E501

        Вызывает кастомный метод, определенный специально для вашей организации  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.call_custom_method_with_http_info(organization_id, method_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int organization_id: Идентификатор организации (required)
        :param str method_name: Название кастомного метода (required)
        :param CallCustomMethod body: Дополнительные параметры, передаваемые методу
        :return: CustomMethodApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['organization_id', 'method_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method call_custom_method" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'organization_id' is set
        if ('organization_id' not in params or
                params['organization_id'] is None):
            raise ValueError("Missing the required parameter `organization_id` when calling `call_custom_method`")  # noqa: E501
        # verify the required parameter 'method_name' is set
        if ('method_name' not in params or
                params['method_name'] is None):
            raise ValueError("Missing the required parameter `method_name` when calling `call_custom_method`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'organization_id' in params:
            path_params['organization_id'] = params['organization_id']  # noqa: E501
        if 'method_name' in params:
            path_params['method_name'] = params['method_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['timepad_implicit']  # noqa: E501

        return self.api_client.call_api(
            '/v1/organizations/{organization_id}/custom_method/{method_name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CustomMethodApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_event_order(self, event_id, order_id, **kwargs):  # noqa: E501
        """Удалить заказ  # noqa: E501

        Устанавливает заказу статус - удалено  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_event_order(event_id, order_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int event_id: Номер события, к которому относится заказ (required)
        :param int order_id: Номер заказа (required)
        :return: RegistrationOrderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_event_order_with_http_info(event_id, order_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_event_order_with_http_info(event_id, order_id, **kwargs)  # noqa: E501
            return data

    def delete_event_order_with_http_info(self, event_id, order_id, **kwargs):  # noqa: E501
        """Удалить заказ  # noqa: E501

        Устанавливает заказу статус - удалено  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_event_order_with_http_info(event_id, order_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int event_id: Номер события, к которому относится заказ (required)
        :param int order_id: Номер заказа (required)
        :return: RegistrationOrderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id', 'order_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_event_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `delete_event_order`")  # noqa: E501
        # verify the required parameter 'order_id' is set
        if ('order_id' not in params or
                params['order_id'] is None):
            raise ValueError("Missing the required parameter `order_id` when calling `delete_event_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['event_id'] = params['event_id']  # noqa: E501
        if 'order_id' in params:
            path_params['order_id'] = params['order_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['timepad_implicit']  # noqa: E501

        return self.api_client.call_api(
            '/v1/events/{event_id}/orders/{order_id}/delete', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RegistrationOrderResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_event(self, event_id, **kwargs):  # noqa: E501
        """Изменить событие  # noqa: E501

        Для того, чтобы редактировать события, вам нужно вызывать метод от имени пользователя, обладающего административным доступом к организации, в котором событие было создано.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_event(event_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int event_id: Номер редактируемого события (required)
        :param EditEvent body: Список изменённых параметров события
        :return: EventResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_event_with_http_info(event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_event_with_http_info(event_id, **kwargs)  # noqa: E501
            return data

    def edit_event_with_http_info(self, event_id, **kwargs):  # noqa: E501
        """Изменить событие  # noqa: E501

        Для того, чтобы редактировать события, вам нужно вызывать метод от имени пользователя, обладающего административным доступом к организации, в котором событие было создано.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_event_with_http_info(event_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int event_id: Номер редактируемого события (required)
        :param EditEvent body: Список изменённых параметров события
        :return: EventResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `edit_event`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['event_id'] = params['event_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['timepad_implicit']  # noqa: E501

        return self.api_client.call_api(
            '/v1/events/{event_id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_event_order(self, event_id, order_id, **kwargs):  # noqa: E501
        """Изменить заказ  # noqa: E501

        Изменяет состав заказа. Этот метод позволяет только изменить ответы на вопросы анкеты регистрации, пометить билеты в заказе как прошедшие контроль доступа или пометить билеты в заказе как оплаченные оффлайн. Менять состав билетов в заказе, параметры платежа, скидок и так далее данный метод не дает.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_event_order(event_id, order_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int event_id: Номер события, к которому относится заказ (required)
        :param int order_id: Номер заказа (required)
        :param EditOrder body: Список изменённых параметров заказа
        :return: RegistrationOrderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_event_order_with_http_info(event_id, order_id, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_event_order_with_http_info(event_id, order_id, **kwargs)  # noqa: E501
            return data

    def edit_event_order_with_http_info(self, event_id, order_id, **kwargs):  # noqa: E501
        """Изменить заказ  # noqa: E501

        Изменяет состав заказа. Этот метод позволяет только изменить ответы на вопросы анкеты регистрации, пометить билеты в заказе как прошедшие контроль доступа или пометить билеты в заказе как оплаченные оффлайн. Менять состав билетов в заказе, параметры платежа, скидок и так далее данный метод не дает.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_event_order_with_http_info(event_id, order_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int event_id: Номер события, к которому относится заказ (required)
        :param int order_id: Номер заказа (required)
        :param EditOrder body: Список изменённых параметров заказа
        :return: RegistrationOrderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id', 'order_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_event_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `edit_event_order`")  # noqa: E501
        # verify the required parameter 'order_id' is set
        if ('order_id' not in params or
                params['order_id'] is None):
            raise ValueError("Missing the required parameter `order_id` when calling `edit_event_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['event_id'] = params['event_id']  # noqa: E501
        if 'order_id' in params:
            path_params['order_id'] = params['order_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['timepad_implicit']  # noqa: E501

        return self.api_client.call_api(
            '/v1/events/{event_id}/orders/{order_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RegistrationOrderResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_event_orders(self, event_id, **kwargs):  # noqa: E501
        """Получить заказы события  # noqa: E501

        Метод возвращает список заказов. Внимание! Это не выгрузка списка билетов, это именно выгрузка списка заказов. Информация по конкретным билетам находится внутри объекта заказа.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_event_orders(event_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int event_id: Номер события, к которому относятся заказы (required)
        :param int limit: Сколько элементов списка вывести
        :param int skip: С какого элемента списка начать вывод
        :param str email: email пользователя
        :param list[str] fields: Список полей, которые нужно вывести
        :return: RegistrationOrdersResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_event_orders_with_http_info(event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_event_orders_with_http_info(event_id, **kwargs)  # noqa: E501
            return data

    def get_event_orders_with_http_info(self, event_id, **kwargs):  # noqa: E501
        """Получить заказы события  # noqa: E501

        Метод возвращает список заказов. Внимание! Это не выгрузка списка билетов, это именно выгрузка списка заказов. Информация по конкретным билетам находится внутри объекта заказа.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_event_orders_with_http_info(event_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int event_id: Номер события, к которому относятся заказы (required)
        :param int limit: Сколько элементов списка вывести
        :param int skip: С какого элемента списка начать вывод
        :param str email: email пользователя
        :param list[str] fields: Список полей, которые нужно вывести
        :return: RegistrationOrdersResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id', 'limit', 'skip', 'email', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_event_orders" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `get_event_orders`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['event_id'] = params['event_id']  # noqa: E501

        query_params = []
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'email' in params:
            query_params.append(('email', params['email']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['timepad_implicit']  # noqa: E501

        return self.api_client.call_api(
            '/v1/events/{event_id}/orders', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RegistrationOrdersResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_events(self, **kwargs):  # noqa: E501
        """Получить список событий  # noqa: E501

        Получение публичной информации о событиях не требует аутентификации. Количество запросов в минуту ограничено.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_events(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Список полей, которые нужно вывести
        :param int limit: Сколько элементов списка вывести
        :param int skip: С какого элемента списка начать вывод
        :param list[str] sort: Поле, по которому сортировать
        :param list[int] category_ids: Категории, к которым принадлежат события
        :param list[int] category_ids_exclude: Категории, к которым не принадлежат события
        :param list[str] cities: Города, события из которых выводить
        :param list[str] cities_exclude: Города, события из которых не выводить
        :param list[int] organization_ids: Номера организаций, события из которых выводить
        :param list[int] organization_ids_exclude: Номера организаций, события из которых не выводить
        :param list[int] event_ids: Номера событий, которые нужно вывести
        :param list[int] event_ids_exclude: Номера событий, которые нужно пропустить
        :param list[str] keywords: Слова, которые должны быть в названии или описании события
        :param list[str] keywords_exclude: Слова, которых не должно быть в названии или описании события
        :param list[str] access_statuses: Список режимов доступа, в которых находятся события. Возможные значения: private, draft, link_only, public. Доступно только организаторам
        :param list[str] moderation_statuses: Список уровней качества, установленных для события модератором. Возможные значения: featured, shown, hidden, not_moderated.
        :param int price_min: Цена, выше которой должен стоить хотя бы один билет события
        :param int price_max: Цена, ниже которой должен стоить хотя бы один билет события
        :param int ad_partner_percent_min: Хотя бы у одного вида билета события партнёрская комиссия в процентах выше этого значения
        :param int ad_partner_percent_max: Хотя бы у одного вида билета партнёрская комиссия в процентах ниже этого значения
        :param int ad_partner_profit_min: Хотя бы у одного вида билета партнёрская комиссия в рублях выше этого значения
        :param int ad_partner_profit_max: Хотя бы у одного вида билета партнёрская комиссия в рублях ниже этого значения
        :param datetime starts_at_min: Дата начала события позднее этого значения
        :param datetime starts_at_max: Дата начала события раньше этого значения
        :param datetime created_at_min: Дата создания события на Timepad позднее этого значения
        :param datetime created_at_max: Дата создания события на Timepad раньше этого значения
        :return: EventsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_events_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_events_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_events_with_http_info(self, **kwargs):  # noqa: E501
        """Получить список событий  # noqa: E501

        Получение публичной информации о событиях не требует аутентификации. Количество запросов в минуту ограничено.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_events_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] fields: Список полей, которые нужно вывести
        :param int limit: Сколько элементов списка вывести
        :param int skip: С какого элемента списка начать вывод
        :param list[str] sort: Поле, по которому сортировать
        :param list[int] category_ids: Категории, к которым принадлежат события
        :param list[int] category_ids_exclude: Категории, к которым не принадлежат события
        :param list[str] cities: Города, события из которых выводить
        :param list[str] cities_exclude: Города, события из которых не выводить
        :param list[int] organization_ids: Номера организаций, события из которых выводить
        :param list[int] organization_ids_exclude: Номера организаций, события из которых не выводить
        :param list[int] event_ids: Номера событий, которые нужно вывести
        :param list[int] event_ids_exclude: Номера событий, которые нужно пропустить
        :param list[str] keywords: Слова, которые должны быть в названии или описании события
        :param list[str] keywords_exclude: Слова, которых не должно быть в названии или описании события
        :param list[str] access_statuses: Список режимов доступа, в которых находятся события. Возможные значения: private, draft, link_only, public. Доступно только организаторам
        :param list[str] moderation_statuses: Список уровней качества, установленных для события модератором. Возможные значения: featured, shown, hidden, not_moderated.
        :param int price_min: Цена, выше которой должен стоить хотя бы один билет события
        :param int price_max: Цена, ниже которой должен стоить хотя бы один билет события
        :param int ad_partner_percent_min: Хотя бы у одного вида билета события партнёрская комиссия в процентах выше этого значения
        :param int ad_partner_percent_max: Хотя бы у одного вида билета партнёрская комиссия в процентах ниже этого значения
        :param int ad_partner_profit_min: Хотя бы у одного вида билета партнёрская комиссия в рублях выше этого значения
        :param int ad_partner_profit_max: Хотя бы у одного вида билета партнёрская комиссия в рублях ниже этого значения
        :param datetime starts_at_min: Дата начала события позднее этого значения
        :param datetime starts_at_max: Дата начала события раньше этого значения
        :param datetime created_at_min: Дата создания события на Timepad позднее этого значения
        :param datetime created_at_max: Дата создания события на Timepad раньше этого значения
        :return: EventsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'limit', 'skip', 'sort', 'category_ids', 'category_ids_exclude', 'cities', 'cities_exclude', 'organization_ids', 'organization_ids_exclude', 'event_ids', 'event_ids_exclude', 'keywords', 'keywords_exclude', 'access_statuses', 'moderation_statuses', 'price_min', 'price_max', 'ad_partner_percent_min', 'ad_partner_percent_max', 'ad_partner_profit_min', 'ad_partner_profit_max', 'starts_at_min', 'starts_at_max', 'created_at_min', 'created_at_max']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_events" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'csv'  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'csv'  # noqa: E501
        if 'category_ids' in params:
            query_params.append(('category_ids', params['category_ids']))  # noqa: E501
            collection_formats['category_ids'] = 'csv'  # noqa: E501
        if 'category_ids_exclude' in params:
            query_params.append(('category_ids_exclude', params['category_ids_exclude']))  # noqa: E501
            collection_formats['category_ids_exclude'] = 'csv'  # noqa: E501
        if 'cities' in params:
            query_params.append(('cities', params['cities']))  # noqa: E501
            collection_formats['cities'] = 'csv'  # noqa: E501
        if 'cities_exclude' in params:
            query_params.append(('cities_exclude', params['cities_exclude']))  # noqa: E501
            collection_formats['cities_exclude'] = 'csv'  # noqa: E501
        if 'organization_ids' in params:
            query_params.append(('organization_ids', params['organization_ids']))  # noqa: E501
            collection_formats['organization_ids'] = 'csv'  # noqa: E501
        if 'organization_ids_exclude' in params:
            query_params.append(('organization_ids_exclude', params['organization_ids_exclude']))  # noqa: E501
            collection_formats['organization_ids_exclude'] = 'csv'  # noqa: E501
        if 'event_ids' in params:
            query_params.append(('event_ids', params['event_ids']))  # noqa: E501
            collection_formats['event_ids'] = 'csv'  # noqa: E501
        if 'event_ids_exclude' in params:
            query_params.append(('event_ids_exclude', params['event_ids_exclude']))  # noqa: E501
            collection_formats['event_ids_exclude'] = 'csv'  # noqa: E501
        if 'keywords' in params:
            query_params.append(('keywords', params['keywords']))  # noqa: E501
            collection_formats['keywords'] = 'csv'  # noqa: E501
        if 'keywords_exclude' in params:
            query_params.append(('keywords_exclude', params['keywords_exclude']))  # noqa: E501
            collection_formats['keywords_exclude'] = 'csv'  # noqa: E501
        if 'access_statuses' in params:
            query_params.append(('access_statuses', params['access_statuses']))  # noqa: E501
            collection_formats['access_statuses'] = 'csv'  # noqa: E501
        if 'moderation_statuses' in params:
            query_params.append(('moderation_statuses', params['moderation_statuses']))  # noqa: E501
            collection_formats['moderation_statuses'] = 'csv'  # noqa: E501
        if 'price_min' in params:
            query_params.append(('price_min', params['price_min']))  # noqa: E501
        if 'price_max' in params:
            query_params.append(('price_max', params['price_max']))  # noqa: E501
        if 'ad_partner_percent_min' in params:
            query_params.append(('ad_partner_percent_min', params['ad_partner_percent_min']))  # noqa: E501
        if 'ad_partner_percent_max' in params:
            query_params.append(('ad_partner_percent_max', params['ad_partner_percent_max']))  # noqa: E501
        if 'ad_partner_profit_min' in params:
            query_params.append(('ad_partner_profit_min', params['ad_partner_profit_min']))  # noqa: E501
        if 'ad_partner_profit_max' in params:
            query_params.append(('ad_partner_profit_max', params['ad_partner_profit_max']))  # noqa: E501
        if 'starts_at_min' in params:
            query_params.append(('starts_at_min', params['starts_at_min']))  # noqa: E501
        if 'starts_at_max' in params:
            query_params.append(('starts_at_max', params['starts_at_max']))  # noqa: E501
        if 'created_at_min' in params:
            query_params.append(('created_at_min', params['created_at_min']))  # noqa: E501
        if 'created_at_max' in params:
            query_params.append(('created_at_max', params['created_at_max']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['timepad_implicit']  # noqa: E501

        return self.api_client.call_api(
            '/v1/events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_events_categories(self, **kwargs):  # noqa: E501
        """Получить список категорий событий  # noqa: E501

        Получает список категорий событий  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_events_categories(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: EventsCategoriesApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_events_categories_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_events_categories_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_events_categories_with_http_info(self, **kwargs):  # noqa: E501
        """Получить список категорий событий  # noqa: E501

        Получает список категорий событий  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_events_categories_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: EventsCategoriesApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_events_categories" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/dictionary/event_categories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventsCategoriesApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_events_statuses(self, **kwargs):  # noqa: E501
        """Получить список статусов событий  # noqa: E501

        Получает список статусов событий  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_events_statuses(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: EventsStatusesApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_events_statuses_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_events_statuses_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_events_statuses_with_http_info(self, **kwargs):  # noqa: E501
        """Получить список статусов событий  # noqa: E501

        Получает список статусов событий  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_events_statuses_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: EventsStatusesApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_events_statuses" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/dictionary/event_statuses', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventsStatusesApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_single_event(self, event_id, **kwargs):  # noqa: E501
        """Получить событие по ID  # noqa: E501

        Получение полной информации по событию. С помощью параметра fields можно регулировать набор полей, который вернет метод.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_single_event(event_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int event_id: Номер события, которые нужно вывести (required)
        :param list[str] fields: Список полей, которые нужно вывести
        :return: EventResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_single_event_with_http_info(event_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_single_event_with_http_info(event_id, **kwargs)  # noqa: E501
            return data

    def get_single_event_with_http_info(self, event_id, **kwargs):  # noqa: E501
        """Получить событие по ID  # noqa: E501

        Получение полной информации по событию. С помощью параметра fields можно регулировать набор полей, который вернет метод.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_single_event_with_http_info(event_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int event_id: Номер события, которые нужно вывести (required)
        :param list[str] fields: Список полей, которые нужно вывести
        :return: EventResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_single_event" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `get_single_event`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['event_id'] = params['event_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['timepad_implicit']  # noqa: E501

        return self.api_client.call_api(
            '/v1/events/{event_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_single_event_order(self, event_id, order_id, **kwargs):  # noqa: E501
        """Получить заказ по ID  # noqa: E501

        Получает заказ по его ID. Обращаем внимание, что номер на билете - это ID билета, а не заказа.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_single_event_order(event_id, order_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int event_id: Номер события, к которому относится заказ (required)
        :param int order_id: Номер заказа (required)
        :param list[str] fields: Список полей, которые нужно вывести
        :return: RegistrationOrderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_single_event_order_with_http_info(event_id, order_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_single_event_order_with_http_info(event_id, order_id, **kwargs)  # noqa: E501
            return data

    def get_single_event_order_with_http_info(self, event_id, order_id, **kwargs):  # noqa: E501
        """Получить заказ по ID  # noqa: E501

        Получает заказ по его ID. Обращаем внимание, что номер на билете - это ID билета, а не заказа.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_single_event_order_with_http_info(event_id, order_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int event_id: Номер события, к которому относится заказ (required)
        :param int order_id: Номер заказа (required)
        :param list[str] fields: Список полей, которые нужно вывести
        :return: RegistrationOrderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id', 'order_id', 'fields']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_single_event_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `get_single_event_order`")  # noqa: E501
        # verify the required parameter 'order_id' is set
        if ('order_id' not in params or
                params['order_id'] is None):
            raise ValueError("Missing the required parameter `order_id` when calling `get_single_event_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['event_id'] = params['event_id']  # noqa: E501
        if 'order_id' in params:
            path_params['order_id'] = params['order_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['timepad_implicit']  # noqa: E501

        return self.api_client.call_api(
            '/v1/events/{event_id}/orders/{order_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RegistrationOrderResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tickets_statuses(self, **kwargs):  # noqa: E501
        """Получить список статусов билетов  # noqa: E501

        Получает список статусов билетов  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tickets_statuses(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: TicketsStatusesApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_tickets_statuses_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_tickets_statuses_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_tickets_statuses_with_http_info(self, **kwargs):  # noqa: E501
        """Получить список статусов билетов  # noqa: E501

        Получает список статусов билетов  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tickets_statuses_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: TicketsStatusesApiResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tickets_statuses" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v1/dictionary/tickets_statuses', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TicketsStatusesApiResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def introspect_token(self, **kwargs):  # noqa: E501
        """Получить информацию о пользователе API  # noqa: E501

        Получить информацию о токене соответственно стандарту ietf-oauth-introspection  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.introspect_token(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: Идентификатор токена
        :return: Introspect
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.introspect_token_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.introspect_token_with_http_info(**kwargs)  # noqa: E501
            return data

    def introspect_token_with_http_info(self, **kwargs):  # noqa: E501
        """Получить информацию о пользователе API  # noqa: E501

        Получить информацию о токене соответственно стандарту ietf-oauth-introspection  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.introspect_token_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token: Идентификатор токена
        :return: Introspect
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method introspect_token" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/introspect', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Introspect',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def introspect_token_post(self, **kwargs):  # noqa: E501
        """Получить информацию о пользователе API  # noqa: E501

        Получить информацию о токене соответственно стандарту ietf-oauth-introspection. Аналогичен методу 'GET /introspect', но может быть использован в том случае, когда нужно по каким-либо причинам скрыть проверяемый токен.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.introspect_token_post(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token:
        :return: Introspect
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.introspect_token_post_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.introspect_token_post_with_http_info(**kwargs)  # noqa: E501
            return data

    def introspect_token_post_with_http_info(self, **kwargs):  # noqa: E501
        """Получить информацию о пользователе API  # noqa: E501

        Получить информацию о токене соответственно стандарту ietf-oauth-introspection. Аналогичен методу 'GET /introspect', но может быть использован в том случае, когда нужно по каким-либо причинам скрыть проверяемый токен.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.introspect_token_post_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str token:
        :return: Introspect
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method introspect_token_post" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'token' in params:
            form_params.append(('token', params['token']))  # noqa: E501

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/introspect', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Introspect',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reject_event_order(self, event_id, order_id, **kwargs):  # noqa: E501
        """Отклонить заказ  # noqa: E501

        Устанавливает заказу статус - отклонено  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reject_event_order(event_id, order_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int event_id: Номер события, к которому относится заказ (required)
        :param int order_id: Номер заказа (required)
        :return: RegistrationOrderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reject_event_order_with_http_info(event_id, order_id, **kwargs)  # noqa: E501
        else:
            (data) = self.reject_event_order_with_http_info(event_id, order_id, **kwargs)  # noqa: E501
            return data

    def reject_event_order_with_http_info(self, event_id, order_id, **kwargs):  # noqa: E501
        """Отклонить заказ  # noqa: E501

        Устанавливает заказу статус - отклонено  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reject_event_order_with_http_info(event_id, order_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int event_id: Номер события, к которому относится заказ (required)
        :param int order_id: Номер заказа (required)
        :return: RegistrationOrderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_id', 'order_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reject_event_order" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_id' is set
        if ('event_id' not in params or
                params['event_id'] is None):
            raise ValueError("Missing the required parameter `event_id` when calling `reject_event_order`")  # noqa: E501
        # verify the required parameter 'order_id' is set
        if ('order_id' not in params or
                params['order_id'] is None):
            raise ValueError("Missing the required parameter `order_id` when calling `reject_event_order`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_id' in params:
            path_params['event_id'] = params['event_id']  # noqa: E501
        if 'order_id' in params:
            path_params['order_id'] = params['order_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['timepad_implicit']  # noqa: E501

        return self.api_client.call_api(
            '/v1/events/{event_id}/orders/{order_id}/reject', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RegistrationOrderResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
